<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Labirinto - DFS + Risoluzione</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      margin: 0;
      background: #f4f4f4;
    }

    h1 {
      margin: 20px 0;
    }

    #controls {
      margin-bottom: 20px;
    }

    button {
      padding: 10px 20px;
      margin: 5px;
      font-size: 1rem;
      cursor: pointer;
    }

    #maze {
      display: grid;
      justify-content: center;
      margin: 0 auto;
    }

    .cell {
      width: 20px;
      height: 20px;
      box-sizing: border-box;
      border: 1px solid #000;
      position: relative;
    }

    .cell.visited {
      background-color: #e0e0e0;
    }

    .cell.start {
      background-color: #5cb85c !important;
    }

    .cell.end {
      background-color: #d9534f !important;
    }

    .cell.path {
      background-color: #5bc0de !important;
    }

    @media (max-width: 600px) {
      .cell {
        width: 15px;
        height: 15px;
      }
    }
  </style>
</head>
<body>
  <h1>Labirinto DFS con Risoluzione</h1>
  <div id="controls">
    <button id="generate">Genera</button>
    <button id="solve">Risolvi</button>
    <button id="reset">Reset</button>
  </div>
  <div id="maze"></div>

  <script>
    const rows = 20;
    const cols = 20;
    let grid = [];
    let stack = [];

    const mazeContainer = document.getElementById('maze');
    const generateBtn = document.getElementById('generate');
    const solveBtn = document.getElementById('solve');
    const resetBtn = document.getElementById('reset');

    class Cell {
      constructor(row, col) {
        this.row = row;
        this.col = col;
        this.visited = false;
        this.walls = { top: true, right: true, bottom: true, left: true };
        this.element = document.createElement('div');
        this.element.classList.add('cell');
        mazeContainer.appendChild(this.element);
      }

      updateStyle() {
        const { top, right, bottom, left } = this.walls;
        this.element.style.borderTop = top ? '1px solid black' : 'none';
        this.element.style.borderRight = right ? '1px solid black' : 'none';
        this.element.style.borderBottom = bottom ? '1px solid black' : 'none';
        this.element.style.borderLeft = left ? '1px solid black' : 'none';
      }

      getUnvisitedNeighbors() {
        const dirs = [
          { r: -1, c: 0, wall: 'top', opposite: 'bottom' },
          { r: 0, c: 1, wall: 'right', opposite: 'left' },
          { r: 1, c: 0, wall: 'bottom', opposite: 'top' },
          { r: 0, c: -1, wall: 'left', opposite: 'right' },
        ];
        const neighbors = [];

        for (const dir of dirs) {
          const r = this.row + dir.r;
          const c = this.col + dir.c;
          if (r >= 0 && r < rows && c >= 0 && c < cols && !grid[r][c].visited) {
            neighbors.push({ cell: grid[r][c], dir });
          }
        }

        return neighbors;
      }

      removeWall(neighbor, dir) {
        this.walls[dir.wall] = false;
        neighbor.walls[dir.opposite] = false;
      }
    }

    function setupGrid() {
      mazeContainer.innerHTML = '';
      mazeContainer.style.gridTemplateRows = `repeat(${rows}, 1fr)`;
      mazeContainer.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
      grid = [];
      for (let r = 0; r < rows; r++) {
        const row = [];
        for (let c = 0; c < cols; c++) {
          const cell = new Cell(r, c);
          row.push(cell);
        }
        grid.push(row);
      }
      grid[0][0].element.classList.add('start');
      grid[rows - 1][cols - 1].element.classList.add('end');
    }

    function generateMaze() {
      setupGrid();
      stack = [];
      const start = grid[0][0];
      start.visited = true;
      stack.push(start);

      while (stack.length > 0) {
        const current = stack[stack.length - 1];
        const neighbors = current.getUnvisitedNeighbors();

        if (neighbors.length > 0) {
          const { cell: next, dir } = neighbors[Math.floor(Math.random() * neighbors.length)];
          current.removeWall(next, dir);
          next.visited = true;
          stack.push(next);
        } else {
          stack.pop();
        }
      }

      for (let row of grid)
        for (let cell of row)
          cell.updateStyle();
    }

    async function solveMaze() {
      const queue = [[0, 0]];
      const visited = Array.from({ length: rows }, () => Array(cols).fill(false));
      const prev = Array.from({ length: rows }, () => Array(cols).fill(null));
      visited[0][0] = true;

      const delay = (ms) => new Promise(res => setTimeout(res, ms));

      while (queue.length > 0) {
        const [r, c] = queue.shift();
        const cell = grid[r][c];

        if (r === rows - 1 && c === cols - 1) break;

        const dirs = [
          { dr: -1, dc: 0, wall: 'top', check: (cell) => !cell.walls.top },
          { dr: 0, dc: 1, wall: 'right', check: (cell) => !cell.walls.right },
          { dr: 1, dc: 0, wall: 'bottom', check: (cell) => !cell.walls.bottom },
          { dr: 0, dc: -1, wall: 'left', check: (cell) => !cell.walls.left },
        ];

        for (let dir of dirs) {
          const nr = r + dir.dr;
          const nc = c + dir.dc;
          if (
            nr >= 0 && nr < rows && nc >= 0 && nc < cols &&
            !visited[nr][nc] &&
            dir.check(cell)
          ) {
            visited[nr][nc] = true;
            prev[nr][nc] = [r, c];
            queue.push([nr, nc]);
          }
        }
        await delay(10);
      }

      let path = [];
      let curr = [rows - 1, cols - 1];
      while (curr) {
        path.push(curr);
        curr = prev[curr[0]][curr[1]];
      }

      path.reverse();
      for (let [r, c] of path) {
        const cell = grid[r][c];
        if (!cell.element.classList.contains('start') && !cell.element.classList.contains('end')) {
          cell.element.classList.add('path');
          await delay(20);
        }
      }
    }

    generateBtn.onclick = generateMaze;
    resetBtn.onclick = setupGrid;
    solveBtn.onclick = solveMaze;

    setupGrid();
  </script>
</body>
</html>
