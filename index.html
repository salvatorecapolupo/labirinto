<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Simulatore Labirinto - DFS & Backtracking</title>
  <style>
    body {
      margin: 0;
      font-family: monospace;
      background: black;
      color: #00ffcc;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    canvas {
      background: #000033;
      touch-action: none;
      border: 5px solid #00ffff;
      box-shadow: 0 0 20px #00ffff;
    }
    #controls {
      margin-top: 10px;
    }
    button {
      margin: 5px;
      padding: 10px 15px;
      font-size: 1rem;
      background-color: #000;
      border: 1px solid #00ffff;
      color: #00ffff;
      cursor: pointer;
    }
    button:hover {
      background-color: #002244;
    }
    #info {
      max-width: 600px;
      margin: 10px;
      font-size: 0.9rem;
    }
    #legend {
      margin: 10px;
      font-size: 1rem;
      color: #ffffff;
    }
    #log {
      background-color: #001122;
      border: 1px solid #00aaaa;
      max-width: 90%;
      margin: 10px;
      padding: 10px;
      height: 100px;
      overflow-y: auto;
      font-size: 0.85rem;
    }
  </style>
</head>
<body>
  <h1>Labirinto con DFS & Backtracking</h1>
  <canvas id="mazeCanvas"></canvas>
  <div id="legend">Legenda: <span style="color: yellow">i = Inizio</span>, <span style="color: lime">f = Fine</span></div>
  <div id="controls">
    <button onclick="generateMaze()">Genera</button>
    <button onclick="solveMazeStepByStep()">Risolvi</button>
    <button onclick="resetMaze()">Reset</button>
    <button onclick="verifyUserPath()">Testa Soluzione</button>
  </div>
  <div id="info">
    <p><strong>Come funziona:</strong> Il labirinto viene generato usando <em>Depth-First Search</em> (DFS), una tecnica che visita ogni cella andando il più a fondo possibile prima di tornare indietro (<strong>backtracking</strong>) quando non trova più vie libere. Questo garantisce un labirinto completo con una sola uscita possibile.</p>
    <p><strong>Backtracking</strong> significa provare una strada, e se non funziona, tornare indietro fino al punto dove si può fare una nuova scelta. È come esplorare un labirinto segnandosi il percorso, e cancellando le vie sbagliate.</p>
  </div>
  <div id="log"></div>
  <script>
    const canvas = document.getElementById("mazeCanvas");
    const ctx = canvas.getContext("2d");
    const logBox = document.getElementById("log");

    function logStep(message) {
      const line = document.createElement("div");
      line.textContent = message;
      logBox.appendChild(line);
      logBox.scrollTop = logBox.scrollHeight;
      if (logBox.childElementCount > 20) {
        logBox.removeChild(logBox.firstChild);
      }
    }

    let cols, rows, cellSize;
    let maze = [];
    let stack = [];
    let userPath = [];
    const wallThickness = 3;
    let entryCell, exitCell;

    function setupCanvas() {
      const minDim = Math.min(window.innerWidth, window.innerHeight * 0.6);
      cellSize = 40;
      cols = Math.floor(minDim / cellSize);
      rows = cols;
      canvas.width = cols * cellSize;
      canvas.height = rows * cellSize;
    }

    class Cell {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.walls = [true, true, true, true];
        this.visited = false;
      }

      draw(current = false, color = "white") {
        const x = this.x * cellSize;
        const y = this.y * cellSize;

        ctx.strokeStyle = color;
        ctx.lineWidth = wallThickness;

        if (this.walls[0]) drawLine(x, y, x + cellSize, y);
        if (this.walls[1]) drawLine(x + cellSize, y, x + cellSize, y + cellSize);
        if (this.walls[2]) drawLine(x + cellSize, y + cellSize, x, y + cellSize);
        if (this.walls[3]) drawLine(x, y + cellSize, x, y);

        if (current) {
          ctx.fillStyle = color;
          ctx.beginPath();
          ctx.arc(x + cellSize / 2, y + cellSize / 2, 8, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }

    function drawLine(x1, y1, x2, y2) {
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
    }

    function index(x, y) {
      if (x < 0 || y < 0 || x >= cols || y >= rows) return -1;
      return x + y * cols;
    }

    function generateMaze() {
      logStep("Generazione nuovo labirinto...");
      setupCanvas();
      maze = [];
      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          maze.push(new Cell(x, y));
        }
      }

      entryCell = maze[index(0, Math.floor(rows / 2))];
      exitCell = maze[index(cols - 1, Math.floor(Math.random() * rows))];
      entryCell.walls[3] = false;
      exitCell.walls[1] = false;

      let current = entryCell;
      current.visited = true;
      stack = [current];

      const interval = setInterval(() => {
        if (stack.length === 0) {
          clearInterval(interval);
          drawMaze();
          markPoints();
          logStep("Labirinto generato!");
          return;
        }
        drawMaze();
        current = stack[stack.length - 1];
        let next = getUnvisitedNeighbor(current);
        if (next) {
          next.visited = true;
          stack.push(next);
          removeWalls(current, next);
          logStep(`Avanzamento: (${next.x}, ${next.y})`);
        } else {
          stack.pop();
        }
      }, 20);
    }

    function getUnvisitedNeighbor(cell) {
      const neighbors = [];
      const { x, y } = cell;
      const directions = [
        [x, y - 1, 0],
        [x + 1, y, 1],
        [x, y + 1, 2],
        [x - 1, y, 3],
      ];
      for (const [nx, ny, dir] of directions) {
        const idx = index(nx, ny);
        if (idx >= 0 && !maze[idx].visited) {
          neighbors.push({ cell: maze[idx], dir });
        }
      }
      return neighbors.length ? neighbors[Math.floor(Math.random() * neighbors.length)].cell : null;
    }

    function removeWalls(a, b) {
      const dx = b.x - a.x;
      const dy = b.y - a.y;
      if (dx === 1) { a.walls[1] = false; b.walls[3] = false; }
      if (dx === -1) { a.walls[3] = false; b.walls[1] = false; }
      if (dy === 1) { a.walls[2] = false; b.walls[0] = false; }
      if (dy === -1) { a.walls[0] = false; b.walls[2] = false; }
    }

    function drawMaze() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      maze.forEach(cell => cell.draw());
      if (userPath.length) drawUserPath();
    }

    function markPoints() {
      entryCell.draw(true, "yellow");
      exitCell.draw(true, "lime");
    }

    function solveMazeStepByStep() {
      logStep("Avvio della risoluzione con DFS...");
      let start = entryCell;
      let end = exitCell;
      let visited = new Set();
      let path = [];

      function dfs(current) {
        if (current === end) return true;
        visited.add(current);
        for (let i = 0; i < 4; i++) {
          if (!current.walls[i]) {
            const dx = [0, 1, 0, -1][i];
            const dy = [-1, 0, 1, 0][i];
            const ni = index(current.x + dx, current.y + dy);
            if (ni >= 0 && !visited.has(maze[ni])) {
              if (dfs(maze[ni])) {
                path.push(current);
                return true;
              }
            }
          }
        }
        return false;
      }

      dfs(start);
      path.reverse();

      let i = 0;
      const interval = setInterval(() => {
        if (i >= path.length) {
          clearInterval(interval);
          logStep("Percorso trovato!");
          return;
        }
        drawMaze();
        markPoints();
        path[i].draw(true, "red");
        logStep(`Passo ${i + 1}: (${path[i].x}, ${path[i].y})`);
        i++;
      }, 50);
    }

    function resetMaze() {
      maze.forEach(c => c.visited = false);
      userPath = [];
      drawMaze();
      markPoints();
      logStep("Maze resettato.");
    }

    function drawUserPath() {
      ctx.strokeStyle = "cyan";
      ctx.lineWidth = 5;
      ctx.beginPath();
      for (let i = 0; i < userPath.length; i++) {
        const x = userPath[i].x * cellSize + cellSize / 2;
        const y = userPath[i].y * cellSize + cellSize / 2;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();
    }

    function verifyUserPath() {
      if (userPath.length === 0) return alert("Traccia un percorso!");

      function isPathValid(path) {
        for (let i = 1; i < path.length; i++) {
          const a = path[i - 1];
          const b = path[i];
          const dx = b.x - a.x;
          const dy = b.y - a.y;
          let dir;
          if (dx === 1 && dy === 0) dir = 1;
          else if (dx === -1 && dy === 0) dir = 3;
          else if (dx === 0 && dy === 1) dir = 2;
          else if (dx === 0 && dy === -1) dir = 0;
          else return false;

          if (a.walls[dir] || b.walls[(dir + 2) % 4]) return false;
        }
        return true;
      }

      if (userPath[0] === entryCell && userPath[userPath.length - 1] === exitCell && isPathValid(userPath)) {
        logStep("Percorso utente valido!");
        alert("Bravo! Hai trovato l'uscita!");
      } else {
        logStep("Percorso utente non valido.");
        alert("Percorso non valido o non completo.");
      }
    }

    canvas.addEventListener("pointerdown", e => {
      userPath = [];
      const rect = canvas.getBoundingClientRect();
      const x = Math.floor((e.clientX - rect.left) / cellSize);
      const y = Math.floor((e.clientY - rect.top) / cellSize);
      const idx = index(x, y);
      if (idx >= 0) userPath.push(maze[idx]);
    });

    canvas.addEventListener("pointermove", e => {
      if (e.buttons === 1 || e.pointerType === "touch") {
        const rect = canvas.getBoundingClientRect();
        const x = Math.floor((e.clientX - rect.left) / cellSize);
        const y = Math.floor((e.clientY - rect.top) / cellSize);
        const idx = index(x, y);
        if (idx >= 0 && maze[idx] !== userPath[userPath.length - 1]) {
          userPath.push(maze[idx]);
          drawMaze();
          markPoints();
        }
      }
    });

    generateMaze();
  </script>
</body>
</html>
